확실하게 알고있는 것들은 모두 제외했음.<br>
<br>

## 벡터
플레이어 위치를 (2, 4)라고 하고 적의 위치를 (-4, 1)이라고 하자.<br>
플레이어가 적의 위치로 가고 싶을 때 얼만큼 어느 방향으로 가야 하는지 알기 위해선<br>
적의 위치(-4, 1)에서 플레이어의 위치(2, 4)를 빼면 된다.<br>
<br>

👉 **적 위치좌표 - 플레이어 위치좌표 = 적으로 향하는 벡터**<br>
좌표간의 뺄셈은 좌표간의 간격을 의미하고 해당 값 자체는 적으로 향하는 벡터가 된다.<br>
<br>
<br>

## 평행이동과 좌표계 + 부모 자식 관계
👉 **translate(); -> 평행이동 함수로 현재위치에서 매개변수로 넣어준 벡터만큼 평행이동 시켜준다.**<br>
평행이동은 디폴트로 로컬좌표계를 기준으로 이동한다.(당연히 옵션으로 월드좌표계를 기반으로 이동시킬 수 있음.)<br>

⭐ **자식 오브젝트의 Transform은 부모 오브젝트를 원점으로하는 Local 좌표계다.**<br>
<br>
<br>

## 회전과 쿼터니언
인스펙터에서 오일러 회전 좌표계를 이용하는 것 처럼 보이지만, 유니티는 쿼터니언 값을 이용해 회전 시스템을<br>
운용하기 때문에, 코드 상에서 회전값을 지정해줄때에는 쿼터니언값을 대입해주어야 한다.<br>
-> 인스펙터에 오일러 값을 넣어도 내부적으로는 쿼터니언으로 변환하여 사용하는 것.<br>

👉 **Rotate(); -> 현재 회전값에서 매개변수로 넣어준 회전값만큼 회전시킨다.**<br>

회전값을 더할때 오일러 회전 좌표계는 +를 이용해서 더하면 되지만, 오일러 좌표계는 매트릭스로 이루어져 있기에<br>
⭐ **곱하기** ⭐ 를 이용해서 더해주어야 한다.<br>

```c#
Quaternion originalRotation = Quaternion.Euler(new Vector3(45, 0, 0));

Quaternion plusRotation = Quaternion.Euler(new Vector3(30, 0, 0));

Quaternion targetRotation = originalRotation * plusRotation; 
```
<br>

⭐ **회전은 대부분 로컬좌표계를 기준으로** ⭐ 이루어진다는 점을 유의해야 한다.<br>
(30, 45, 60)도로 회전되어있는 오브젝트를 x축으로 30도 더 회전 시킨다면 어떻게 될까?<br>
-> (60, 45, 60)이 아니라 (40.505, 79.715, 80.538)이 된다.<br>
그 이유는 글로벌 기준이었다면 (60, 45, 60)이 됐겠지만, 이미 (30, 45, 60)만큼 회전되어있는 **로컬좌표계** 를 기준으로<br>
더 회전을 하기 때문에 전혀 다른 값이 나오는 것이다.<br>
<br>
-> 인스펙터에서의 로테이션값은 글로벌 기준이라 함.<br>
<br>
<br>

