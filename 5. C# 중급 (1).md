확실하게 알고있는 것들은 모두 제외했음.<br>
<br>

## 🔔 벡터
플레이어 위치를 (2, 4)라고 하고 적의 위치를 (-4, 1)이라고 하자.<br>
플레이어가 적의 위치로 가고 싶을 때 얼만큼 어느 방향으로 가야 하는지 알기 위해선<br>
적의 위치(-4, 1)에서 플레이어의 위치(2, 4)를 빼면 된다.<br>
<br>

👉 **적 위치좌표 - 플레이어 위치좌표 = 적으로 향하는 벡터**<br>
좌표간의 뺄셈은 좌표간의 간격을 의미하고 해당 값 자체는 적으로 향하는 벡터가 된다.<br>
<br>
<br>

## 🔔 평행이동과 좌표계 + 부모 자식 관계
👉 **translate(); -> 평행이동 함수로 현재위치에서 매개변수로 넣어준 벡터만큼 평행이동 시켜준다.**<br>
평행이동은 디폴트로 로컬좌표계를 기준으로 이동한다.(당연히 옵션으로 월드좌표계를 기반으로 이동시킬 수 있음.)<br>

⭐ **자식 오브젝트의 Transform은 부모 오브젝트를 원점으로하는 Local 좌표계다.**<br>
<br>
<br>

## 🔔 회전과 쿼터니언
인스펙터에서 오일러 회전 좌표계를 이용하는 것 처럼 보이지만, 유니티는 쿼터니언 값을 이용해 회전 시스템을<br>
운용하기 때문에, 코드 상에서 회전값을 지정해줄때에는 쿼터니언값을 대입해주어야 한다.<br>
-> 인스펙터에 오일러 값을 넣어도 내부적으로는 쿼터니언으로 변환하여 사용하는 것.<br>

👉 **Rotate(); -> 현재 회전값에서 매개변수로 넣어준 회전값만큼 회전시킨다.**<br>

회전값을 더할때 오일러 회전 좌표계는 +를 이용해서 더하면 되지만, 오일러 좌표계는 매트릭스로 이루어져 있기에<br>
⭐ **곱하기** ⭐ 를 이용해서 더해주어야 한다.<br>

```c#
Quaternion originalRotation = Quaternion.Euler(new Vector3(45, 0, 0));

Quaternion plusRotation = Quaternion.Euler(new Vector3(30, 0, 0));

Quaternion targetRotation = originalRotation * plusRotation; 
```
<br>

⭐ **회전은 대부분 로컬좌표계를 기준으로** ⭐ 이루어진다는 점을 유의해야 한다.<br>
(30, 45, 60)도로 회전되어있는 오브젝트를 x축으로 30도 더 회전 시킨다면 어떻게 될까?<br>
-> (60, 45, 60)이 아니라 (40.505, 79.715, 80.538)이 된다.<br>
그 이유는 글로벌 기준이었다면 (60, 45, 60)이 됐겠지만, 이미 (30, 45, 60)만큼 회전되어있는 **로컬좌표계** 를 기준으로<br>
더 회전을 하기 때문에 전혀 다른 값이 나오는 것이다.<br>
<br>
<br>

## 🔔 오버로딩
내부 동작은 유사한데 굳이 여러개의 이름으로 나누어 각 메소드를 만들게되면, 사용 시 굉장히 불편해질 수 있다.<br>
이럴때 메소드명을 똑같이하고 매개변수의 타입이나 매개변수의 갯수를 다르게해서 선언을 할 수 있다.<br>
즉 동일한 메소드 명으로 호출하되, 넘겨주는 매개변수의 타입이나 갯수에 따라 호출되는 메소드가 달라지는 것.<br>
👉 오버로딩된 메서드들은 매개변수에 의해서만 구별될 수 있으므로 반환 타입은 오버로딩을 구현하는데 아무런 영향을 주지 못한다는 것에 주의해야한다.
<br>
<br>

## 🔔 Static
C#에서 static은 메서드나 필드가 클래스의 인스턴스가 아닌 ⭐ **클래스 자체에 소속되도록 지정하는 한정자이다.**<br>
static 필드는 프로그램 실행 후 해당 클래스가 처음으로 사용될 때 한번 초기화되어(프로그램 종료 시 해제)<br>
계속 동일한 메모리를 사용하게 된다. **즉 프로그램 실행 후 한번 메모리에 할당되어, 인스턴스화 없이도 사용이 가능하며<br>
공유가 가능해진다. 고로 전역적으로 공유를 해야하는 필드가 필요하거나, 인스턴스화 없이 간편하게 메소드를 사용하고자<br>
할 때 사용하는 한정자이다. (클래스에 소속된 필드이기에 각 객체마다 새로 할당되지 않는다.)**<br>
-> static 클래스는 모든 필드와 메소드가 static 이어야 한다.<br>
<br>
<br>

## 🔔 코루틴
(Unity는 기본적으로 싱글 스레드 시스템이기 때문에 코루틴을 적극 활용한다.)<br>
코루틴을 알기 전에 서브루틴이라는 것부터 확인해야 한다.<br>
⭐ **서브루틴이란 어떤 동작을 하기위해 함수가 호출이 되었고 그 함수의 동작이 끝나면 자신을 호출하였던 메인루틴으로 돌아오는 경우를 말한다.**<br>

코루틴이란 간단하게 하나의 진입점과 하나의 탈출점이 있는 서브루틴과 다르게 ⭐ **다양한 진입점과 다양한 탈출점이 있는 루틴이라 생각하면 된다.**
즉, 메인 루틴에서 어떤 함수를 호출하고 그 함수가 동작 하다 중간에 멈추고 다시 메인 루틴의 동작을 하다 다시 멈춘 함수로 돌아와서 마저 작업을 하게 된다.
⭐⭐**마치 라운드 로빈 스케줄링처럼 여러 루틴들을 번갈아가며 수행하여 마치 병렬 수행인 것 처럼, 멀티 스레딩을 사용하는 것 처럼 보이게 해준다.** ⭐⭐<br>

👉 이러한 코루틴은 디버깅과 코드 분석이 어려워질 수 있으므로 명확한 상황에서만 사용하고 남발하면 안된다.<br>
<br>

👉 **Invoke vs Coroutine**<br>
Invoke도 코루틴과 유사하게 특정 시간 뒤 호출될 수 있으며 InvokeRepeating을 사용하면 거의 동일하게 사용이 가능하다.<br>
그렇다면 둘의 차이점은 무엇이 있을까?<br>

1. Invoke는 함수자체가 반환값, 매개변수가 없어야 한다는 제약이 존재한다.
2. 코루틴은 매개변수에 대한 제약이 없다.
3. ⭐ Invoke는  Game Object의 Active 상태에 상관없이 동작한다. ⭐
4. IsInvoking을 통해 인보크의 실행 여부를 알 수 있다.

-> ⭐⭐ **코루틴은 좀 더 복잡하고 유연한 코딩이 가능해서 InvokeRepeating으로 대체되지 않는다.** ⭐⭐<br>
<br>

👉 **Coroutine 실행 법 차이**<br>
코루틴을 실행할때에는 코루틴의 이름(String)으로 실행하거나, 함수 실행하듯이 실행하는 방식이 존재하는데<br>
이 두 방식은 차이를 보인다.<br>

```c#
void Start()
{
  StartCoroutine(Test());
}

IEnumerator Test()
{
  while(true)
  {
    yield return null;
  }
}
```
<br>

위처럼 함수 실행하듯이 코루틴을 실행하게 되면, StopCoroutine(Test());와 같이 ⭐ **해당** 코루틴을 중단 할 수 없다.<br>
이는 맨 처음 코루틴을 실행하는 부분에서 반환하는 ⭐ **IEnumerator 변수를 이용해야 중단이 가능하다.**<br>
예시 코드는 아래와 같다.<br>

```c#
IEnumerator enumerator;

void Start()
{
  enumerator = Test(); //반환
  StartCoroutine(enumerator); //실행
}

void Update()
{
  if(Input.GetKey(KeyCode.Space))
  {
    StopCoroutine(enumerator); //이런 식으로 중단이 가능하다.
  }
}

IEnumerator Test()
{
  while(true)
  {
    yield return null;
  }
}
```
<br>

코루틴의 이름으로 실행시키는 경우 **특별한 과정없이 곧바로 중단** 시킬 수 있다.<br>
하지만 유의할 점은 위처럼 IEnumerator 변수를 이용하거나, 함수 실행하듯이 실행한 코루틴을 이름만으로 중단 할 수 없다는 것.<br>
예시 코드는 아래와 같다.<br>

```c#
void Start()
{
  StartCoroutine("Test"); //실행
}

void Update()
{
  if(Input.GetKey(KeyCode.Space))
  {
    StopCoroutine("Test"); //이런 식으로 중단이 가능하다.
  }
}

IEnumerator Test()
{
  while(true)
  {
    yield return null;
  }
}
```
<br>

⭐⭐ **가장 큰 차이점은 매개변수가 존재할 때 이다.<br>
매개변수가 1개 존재할 때에는 두 방식 모두 사용이 가능하다. (코루틴의 이름을 사용하는 경우 박싱이 일어나 성능저하)<br>
하지만 매개변수가 2개 이상인 경우에는 코루틴의 이름을 이용하여 호출하는 것이 불가능하다.<br>
-> 구조체나 클래스를 이용하면 가능은 하겠지만 굳이?** ⭐⭐<br>
<br>
<br>

