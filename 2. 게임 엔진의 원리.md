## 게임 엔진을 사용하는 이유

<img src="https://user-images.githubusercontent.com/43705434/123098540-37a44100-d46c-11eb-9e99-7aab4c065ab9.PNG" width="450" height="250"><br>
<br>

게임 엔진은 Low-Level을 감싸고 있는 이미 완성된 기반 코드를 제공한다.<br>
고로 개발자는 직접 개발할 필요 없이, 이미 구현되어 제공되는 기능들을 재사용하기만 하면 되기 때문이다.<br>
이렇게 게임 엔진의 코드를 ⭐ **재사용 함으로써, 향상된 생산성**을 기대할 수 있게 된다.<br>
-> ⭐ **Unity는 컴포넌트 시스템을 통해서 재사용 시스템**을 제공한다.<br>
-> 컴포넌트 시스템을 이해하려면 **상속**부터 이해를 해야한다.<br>
<br>
<br>

<img src="https://user-images.githubusercontent.com/43705434/123098552-38d56e00-d46c-11eb-9aea-95fdfeccfe95.PNG" width="450" height="250"><br>
<br>

상속 설명은 Pass.<br>
<br>
<br>

## 완벽한 Base Class를 만드는 것은 불가능하다.
미래에 사용될 기능들의 **최소 필수 집합**을 미리 예상하는 것은 매우 힘든 일이다.<br>
그렇기 때문에 완벽한 Base Class(부모)를 설계한다는 것은 불가능에 가깝다.<br>
이말은 즉슨, 추후 해당 클래스를 상속하게될 여러 자식클래스들 중 필요하지 않은<br>
기능들까지 물려받아야하는 경우가 생긴다는 얘기이다. (⭐ 선택적인 상속 불가능)<br>
<br>

<img src="https://user-images.githubusercontent.com/43705434/123098546-38d56e00-d46c-11eb-8760-7d48c26a2b32.PNG" width="450" height="250"><br>
<br>

**예시)**<br>
캐릭터라는 부모클래스와 이를 상속받는 플레이어, NPC, 몬스터 이렇게 3가지 자식 클래스를 만들었으며<br>
캐릭터라는 클래스에 체력 시스템, 공격 시스템, 애니메이션이 구현되어 있다고 해보자.<br>
플레이어 클래스에서는 모든 기능을 상속받는 것이 문제되지 않지만, 체력, 공격 시스템이 필요가 없는 NPC 클래스에서는<br>
이 시스템들이 상속되면 체력이 깎이고 죽을 수도 있게 되는 문제가 생길 수 있다.<br>
몬스터 클래스도 캐릭터 클래스를 상속 받으니 플레이어와 공통적인 애니메이션을 갖게 되지만<br>
몬스터의 애니메이션을 플레이어의 애니메이션과 다르게 하고 싶다면 또 문제가 생길 수 있다.<br>
-> 다시 몬스터만의 애니메이션을 재 작성해서 덮어 씌워야하는 작업이 필요.<br>
<br>

⭐ 즉, 무분별한 상속은 오히려 코드의 재사용을 힘들게 할 수 있다.<br>
<br>

⭐⭐ 따라서 Unity는 A is B(상속) 구조가 아닌 A has B 구조로서 빈 컨테이너에 필요할 때마다 원하는 기능을 갖다 붙여서 포함시키는 방식인 **컴포넌트 시스템**을 사용하는 것이다.
예시로 강아지를 나타내고 싶다면 폐, 다리, 위장, 달리기, 잠자기 등 필요한 컴포넌트만 붙여주는 방식으로 **코드의 재사용**을 이뤄낸다.⭐⭐
<br>
<br>

## GameObject && Component
**게임 오브젝트**<br>
Unity에서 게임 오브젝트란 **스스로 기능을 갖고있지 않은 단순한 Holder** 이며<br>
특정 사물이나 대상을 나타내기 위해 여러 Component들을 추가해서 사용한다.<br>
<br>

**컴포넌트**<br>
게임 오브젝트에 붙일 수 있는, 기능을 가진 부품이라 생각하면 된다.<br>
이러한 컴포넌트는 각자 대표하는 기능들이 이미 완성되어있기 때문에, 다른 컴포넌트에 관심이 없다.<br>
즉 서로 의존도가 없이 ⭐ **독립적으로 동작하는 부품이다.**<br>
<br>

**컴포넌트의 장점**<br>
1. 유연한 재사용
-> 상속만 사용했을 때는 부모의 불필요한 부분까지 물려받았어야 했던 반면 컴포넌트는 원하는 기능만<br>
선택적으로 가져올 수 있기 때문임.<br>
<br>

2. 독립성에 의해 추가와 삭제가 쉽다.
-> 특정 컴포넌트를 삭제한다고해서 다른 기능들, 즉 다른 컴포넌트들에 영향을 미치지 않는다.<br>
<br>

C# 스크립트도 컴포넌트의 일종이다.<br>
<br>
<br>

## 독립적인 컴포넌트는 어떻게 스스로를 동작시킬까?
컴포넌트들은 외부의 간섭을 받지 않는 독립적인 부품들인데, 어떻게 외부에서 기능을 동작하도록 유도할까?<br>

⭐ **Unity Message System**<br>
1. -> 실행하고싶은 기능의 이름을 **메세지**에 담아서 게임세상 즉 모든 오브젝트들에게 **브로드 캐스팅**한다.<br>
2. -> 메세지를 받은 **오브젝트**는 자신의 컴포넌트들에게 해당 메세지를 보낸다.<br>
3. -> 각 **컴포넌트**가 전달받은 메세지를 읽었을때, 자신이 갖고있는 기능과 동일하다면 **실행**한다.<br>
<br>

⭐⭐ 이러한 **메세지 시스템**에 의해 게임 오브젝트, 컴포넌트들은 **복잡한 참조관계**를 알 필요없이 상호작용을 할 수 있게 되는 것이다.
또한 각각의 **라이프 사이클**을 스스로 관리할 수 있게 해준다.⭐⭐<br>
<br>
<br>

## MonoBehaviour
위처럼 Unity가 보내는 **메세지를 받으려면 MonoBehaviour를 상속받아야 한다.**<br>
MonoBehaviour 클래스는 컴포넌트들이 필요한 필수적인 기초 기능들을 제공하며, 유니티의 통제를 받는다.<br>

