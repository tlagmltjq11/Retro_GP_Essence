## Variable and Data Type
👉 변수란 데이터를 저장할 목적으로 사용하는 메모리 공간에 이름을 붙여준 것.<br>
<br>

👉 자료형이란 변수의 종류로, 변수가 저장할 데이터의 타입을 의미한다.<br>
선언된 변수가 어떠한 자료형이냐에 따라서 할당되는 메모리의 크기도 그에 걸맞게 정해진다.<br>
<br>
<br>

## Casting
형변환은 데이터 타입을 변환하는 것을 의미하는데, 암묵적 형변환과 명시적 형변환으로 나뉜다.<br>
<br>

👉 암묵적 형변환<br>
컴파일러가 자동으로 형변환을 하는 것을 의미하며, 데이터가 손실될 우려가 없는 경우에 사용된다.<br>

```c#
int a = 10;
float b;

b = a;
```
<br>

👉 명시적 형변환<br>
사용자가 직접 형태를 변환하는 것으로, 주로 큰 데이터 타입을 작은 데이터 타입으로 변환할 때 사용된다.<br>
-> 데이터의 손실은 사용자의 몫.<br>

```c#
int a;
float b = 10.324f;

a = (int)b;
```
<br>
<br>

## Var & Dynamic
👉 Var<br>
var : 선언시 -> var result = 20; 와 같이 선언과 동시에 자료형이 결정된다.<br>
고로 var result; 이런식으로 선언해둘 수 없다.<br>
즉 선언할때 초기화된 형태로 자료형이 결정됨.<br>
<br>

👉 Dynamic<br>
dynamic : 런타임 -> dynamic result;와 같이 독립적으로 선언이 가능하다.<br>
result = 10; int가 되며 여기에 다시 문자열을 넣으면 자료형이 string 이 된다.<br>
즉 계속해서 변동이 가능하다.<br>
<br>
<br>

## Class, Object, Instance
👉 **Class**<br>
클래스란 객체를 만들어내기 위한 ⭐ **설계도** 혹은 틀 이라고 이해할 수 있겠다.<br>
-> 특정 대상, 객체를 나타내기 위해 연관되어있는 변수와 메서드의 집합으로 표현한 자료형<br>
<br>

👉 **Object**<br>
⭐ **SW 세계에 구현할 대상** 을 의미한다.<br>
-> 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다.<br>
-> oop의 관점에서 클래스의 타입으로 선언되었을 때 ‘객체’라고 부른다.<br>
<br>

👉 **Instance**<br>
설계도를 바탕으로 소프트웨어 세계에 구현된 ⭐ **구체적인 실체** <br>
-> 즉, 객체를 소프트웨어에 실체화 하면 그것을 ‘인스턴스’라고 부른다.<br>
<br>

👉 **자세한 설명**<br>
객체(Object)는 소프트웨어 세계에 구현할 대상이고, 이를 구현하기 위한 설계도가 클래스(Class)이며,
이 설계도에 따라 소프트웨어 세계에 구현된 실체가 인스턴스(Instance)이다.

⭐⭐ 객체(Object)는 현실의 대상(Object)과 비슷하여, 상태나 행동 등을 가지지만, 소프트웨어 관점에서는 그저 콘셉(concept),<br>
즉 사유의 결과일 뿐이다. 소프트웨어에서 객체를 구현하기 위해서는 콘셉 이상으로 많은 것들을 사고하여 구현해야 하므로,<br>
이를 위한 설계도로 클래스를 작성한다. 설계도를 바탕으로 객체를 소프트웨어에 실체화 하면 그것이 인스턴스(Instance)가 되고,<br>
이 과정을 인스턴스화(instantiation)라고 한다. 실체화된 인스턴스는 메모리에 할당된다.⭐⭐ <br>
<br>
<br>

## Value Type and Reference Type
👉 값 형식 : 변수가 값을 담는 데이터 형식.<br>
-> 구조체, 열거형으로 구분가능 -> 정수, bool, 유저구조체 등<br>
<br>

👉 참조 형식 : 변수가 값 대신 값이 있는 곳의 위치(참조)를 담는 데이터 형식.(⭐ 포인터 개념)<br>
-> 클래스, 다이나믹, 오브젝트, 스트링 등<br>
<br>

이 둘을 이해하려면 두 가지 메모리 영역에 대해 알고있어야 한다.<br>
바로 스택(Stack)과 힙(Heap)이다.<br>

이 메모리 영역 중 값 형식과 관련이 있는 것은 스택 메모리 영역이고,<br>
참조 형식과 관련 있는 것은 힙 메모리 영역이다.<br>

값 형식 메모리 구조 <br>
![값형식](https://user-images.githubusercontent.com/43705434/123510756-39fadb00-d6b8-11eb-8e83-f17401af84b6.PNG)<br>
<br>

참조 형식 메모리 구조 <br>
![참조형식](https://user-images.githubusercontent.com/43705434/123510757-3a937180-d6b8-11eb-9bed-a76b340cf23a.PNG)<br>
<br>

값 형식 같은 경우 스택에 메모리가 할당되며 값 자체를 저장하기 때문에, 블록이 끝나게되면 데이터와 변수가<br>
모두 소멸되게 된다.<br>

⭐⭐ 참조 형식은 변수에 값이 있는 메모리의 주소를 저장하기 때문에, 메모리 값 자체는 스택에 저장되지만<br>
실제 데이터인 값은 힙 영역에 저장되게 된다. 그렇기 때문에 블록이 끝나게 되더라도 메모리 주소를 갖던<br>
변수만 소멸되고 힙영역의 데이터는 소멸되지 않는다.<br>
-> 더 이상 사용되지 않으면 GC에 의해 수거된다.⭐⭐<br>

그렇다면 왜 굳이 가비지 컬렉터가 필요한 힙 영역을 사용하는 걸까?<br>
스택에 쌓인 데이터들은 코드 블록이 사라지는 시점에서 함께 제거된다.<br>
이것은 스택에 장점이기도 하지만, 동시에 한계이기도 하다.<br>
코드 블록이 끝나는 시점과 상관없이 데이터를 유지하고 싶을 때는 스택의 구조가 발목을 잡는 요소가 된다.<br>
<br>
<br>
